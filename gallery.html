<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Asset Gallery</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .viewer-card {
            display: flex;
            flex-direction: column;
            aspect-ratio: 3/4;
        }
        .viewer-container {
            flex-grow: 1;
            position: relative;
            background-color: #1f2937;
            border-radius: 0.5rem;
            min-height: 200px;
            overflow: hidden;
        }
        .viewer-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .annotation-callout {
            position: absolute;
            top: 16px;
            right: 16px;
            background-color: rgba(17, 24, 39, 0.9);
            color: #d1d5db;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #4b5563;
            max-width: 250px;
            font-size: 0.875rem;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s;
            opacity: 0;
            z-index: 10;
        }
        .annotation-connector {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9;
            visibility: hidden;
            overflow: visible;
        }
        
        /* Context Menu Styles */
        #context-menu {
            position: fixed;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            padding: 0.5rem 0;
            min-width: 160px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }
        
        #context-menu.hidden {
            display: none;
        }
        
        #context-menu button {
            width: 100%;
            padding: 0.5rem 1rem;
            text-align: left;
            font-size: 0.875rem;
            color: #d1d5db;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        
        #context-menu button:hover {
            background-color: #374151;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 p-4 sm:p-6 lg:p-8">

    <div class="max-w-7xl mx-auto mb-8">
        <h1 class="text-4xl font-bold text-white text-center">3D Asset Gallery</h1>
        <p class="text-lg text-gray-400 text-center mt-2">A curated collection of 3D models.</p>
    </div>

    <div id="gallery-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
        <!-- Viewer instances will be injected here by JavaScript -->
    </div>

    <!-- Context Menu -->
    <div id="context-menu" class="hidden">
        <button id="add-annotation">
            Add annotation
        </button>
    </div>

    <!-- Fullscreen Modal for Expanded View -->
    <div id="fullscreen-modal" class="hidden fixed inset-0 bg-gray-900 z-50 flex flex-col">
        <div class="absolute top-4 left-4 z-10">
            <button id="back-to-gallery" class="text-gray-400 hover:text-white text-xs tracking-wider transition-colors duration-200">
                Back to Gallery
            </button>
        </div>
        <div id="fullscreen-container" class="w-full h-full relative flex"></div>
        <div id="fullscreen-info" class="absolute bottom-0 left-0 right-0 p-6 bg-gradient-to-t from-black/70 via-black/50 to-transparent pointer-events-none">
            <h2 id="fullscreen-title" class="text-2xl font-bold text-white"></h2>
            <p id="fullscreen-description" class="text-base text-gray-300 mt-1"></p>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        // --- CONFIGURE YOUR ASSET DIRECTORIES HERE ---
        // The gallery will be populated by looking for subdirectories with these names inside the 'assets/' folder.
        // The viewers will be populated in this order.
        const assetDirectoryNames = [
            'cubic_explosion'
        ];        const galleryGrid = document.getElementById('gallery-grid');

        class AssetViewer {
            constructor(containerElement, id) {
                this.container = containerElement;
                this.id = id;
                this.currentObject = null;
                this.annotations = [];
                this.annotationSpheres = [];
                this.modelSize = 1;
                this.isCalloutVisible = false;
                this.isDragging = false;
                this.lastIntersection = null;
                this.isExpanded = false;
                this.createDOM();
                this.init();
                this.addEventListeners();
                this.animate();
            }

            createDOM() {
                // Create the main card container (using the existing container)
                this.container.className = 'viewer-card bg-gray-800 rounded-lg overflow-hidden';

                // Create viewer container for the 3D content
                this.viewerContainer = document.createElement('div');
                this.viewerContainer.className = 'viewer-container';

                // Create annotation elements
                this.annotationCallout = document.createElement('div');
                this.annotationCallout.className = 'annotation-callout';
                this.viewerContainer.appendChild(this.annotationCallout);

                this.connectorSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                this.connectorSVG.classList.add('annotation-connector');
                this.connectorLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.connectorLine.setAttribute('stroke', 'rgba(107, 114, 128, 0.7)');
                this.connectorLine.setAttribute('stroke-width', '2');
                this.connectorSVG.appendChild(this.connectorLine);
                this.viewerContainer.appendChild(this.connectorSVG);

                // Create expand button
                this.expandBtn = document.createElement('button');
                this.expandBtn.className = 'text-gray-400 hover:text-white transition-colors duration-200 absolute top-4 right-4 z-10 text-xs tracking-wider';
                this.expandBtn.title = 'View in fullscreen';
                this.expandBtn.innerHTML = 'E<span style="text-transform: lowercase">xpand</span>';
                this.viewerContainer.appendChild(this.expandBtn);

                // Create info section
                const infoContainer = document.createElement('div');
                infoContainer.className = 'p-4';

                this.titleEl = document.createElement('h3');
                this.titleEl.className = 'text-lg font-bold text-white';
                this.titleEl.textContent = `Asset Slot ${this.id + 1}`;

                this.descriptionEl = document.createElement('p');
                this.descriptionEl.className = 'text-sm text-gray-400 mt-2 line-clamp-2';
                this.descriptionEl.textContent = '...';

                infoContainer.appendChild(this.titleEl);
                infoContainer.appendChild(this.descriptionEl);

                // Add everything to the container
                this.container.appendChild(this.viewerContainer);
                this.container.appendChild(infoContainer);
            }
            
            init() {
                // (Initialization logic remains the same)
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1f2937);
                this.camera = new THREE.PerspectiveCamera(75, this.viewerContainer.clientWidth / this.viewerContainer.clientHeight, 0.1, 1000);
                this.camera.position.set(0, 5, 10);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                this.renderer.setSize(this.viewerContainer.clientWidth, this.viewerContainer.clientHeight);
                this.renderer.domElement.className = 'viewer-canvas';
                this.viewerContainer.appendChild(this.renderer.domElement);
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.scene.add(new THREE.AmbientLight(0xffffff, 1.5));
                const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
                directionalLight.position.set(10, 10, 10);
                this.scene.add(directionalLight);
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                new ResizeObserver(() => this.onWindowResize()).observe(this.viewerContainer);
            }

            addEventListeners() {
                // Bind all event handlers to maintain 'this' context
                this.onContextMenuBound = this.onContextMenu.bind(this);
                this.onCanvasClickBound = this.onCanvasClick.bind(this);
                
                this.expandBtn.addEventListener('click', () => this.expand());
                this.renderer.domElement.addEventListener('click', this.onCanvasClickBound);
                
                // Add context menu listeners to both container and canvas
                this.viewerContainer.addEventListener('contextmenu', this.onContextMenuBound);
                this.renderer.domElement.addEventListener('contextmenu', this.onContextMenuBound);
                
                console.log('Added context menu listeners to:', {
                    container: this.viewerContainer,
                    canvas: this.renderer.domElement
                });
                
                this.controls.addEventListener('start', () => {
                    this.isDragging = false;
                    this.hideAnnotationCallout();
                });
                this.controls.addEventListener('change', () => { this.isDragging = true; });

                // Hide context menu on any click outside
                document.addEventListener('click', () => {
                    const contextMenu = document.getElementById('context-menu');
                    contextMenu.classList.add('hidden');
                });

                // Handle "Add annotation" click
                document.getElementById('add-annotation').addEventListener('click', () => {
                    if (this.lastIntersection) {
                        const point = this.lastIntersection.point;
                        const coords = `x: ${point.x.toFixed(2)}, y: ${point.y.toFixed(2)}, z: ${point.z.toFixed(2)}`;
                        this.addAnnotation({
                            position: point,
                            text: coords
                        });
                        this.setAnnotationSpheresVisible(true);
                        const contextMenu = document.getElementById('context-menu');
                        contextMenu.classList.add('hidden');
                    }
                });
            }

            async loadFromDirectory(dirName) {
                try {
                    console.log('Loading directory:', dirName);
                    this.titleEl.textContent = 'Loading...';
                    this.descriptionEl.textContent = 'Please wait while the 3D model loads...';
                    
                    const baseUrl = `assets/${dirName}/`;
                    console.log(`Loading assets from ${baseUrl}`);
                    
                    // Store the texts we'll need later
                    let finalTitle = '';
                    let finalDescription = '';
                    
                    try {
                        // First load the metadata files
                        const [titleText, descriptionText] = await Promise.all([
                            fetch(`${baseUrl}title.md`)
                                .then(r => {
                                    if (!r.ok) throw new Error(`Failed to load title: ${r.status}`);
                                    return r.text();
                                }),
                            fetch(`${baseUrl}description.md`)
                                .then(r => {
                                    if (!r.ok) throw new Error(`Failed to load description: ${r.status}`);
                                    return r.text();
                                })
                        ]);
                        
                        finalTitle = titleText.trim();
                        finalDescription = descriptionText.trim();
                        
                        // Update the text immediately after loading metadata
                        this.titleEl.textContent = finalTitle;
                        this.descriptionEl.textContent = finalDescription;
                        
                    } catch (error) {
                        console.error('Error loading metadata:', error);
                        finalTitle = 'Failed to load title';
                        finalDescription = 'Failed to load description';
                        this.titleEl.textContent = finalTitle;
                        this.descriptionEl.textContent = finalDescription;
                    }

                    // Then load the 3D model
                    await this.loadAssetFromURLs({
                        obj: `${baseUrl}3DModel.obj`,
                        mtl: `${baseUrl}3DModel.mtl`
                    });
                    
                    // Ensure the text is still correct after model loads
                    this.titleEl.textContent = finalTitle;
                    this.descriptionEl.textContent = finalDescription;
                    
                    console.log(`Successfully loaded all assets for ${dirName}`);
                } catch (error) {
                    console.error(`Error loading assets for ${dirName}:`, error);
                    this.titleEl.textContent = 'Error Loading Asset';
                    this.descriptionEl.textContent = 'Failed to load 3D model and assets. Please check the console for details.';
                }
            }

            loadAssetFromURLs({ obj, mtl }) {
                return new Promise((resolve, reject) => {
                    console.log('Starting to load 3D model assets...');
                    
                    const mtlLoader = new MTLLoader();
                    mtlLoader.load(
                        mtl,
                        (materials) => {
                            console.log('Material loaded successfully');
                            materials.preload();
                            const objLoader = new OBJLoader();
                            objLoader.setMaterials(materials);
                            
                            objLoader.load(
                                obj,
                                (object) => {
                                    console.log('3D model loaded successfully');
                                    if (this.currentObject) {
                                        this.scene.remove(this.currentObject);
                                    }
                                    this.currentObject = object;
                                    this.scene.add(object);
                                    this.frameObject(object);
                                    this.createRandomAnnotations(object, 3);
                                    resolve();
                                },
                                (xhr) => {
                                    // Only update loading progress in the console
                                    const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                                    console.log(`Loading 3D model... ${percent}%`);
                                },
                                (error) => {
                                    console.error('Error loading OBJ:', error);
                                    reject(error);
                                }
                            );
                        },
                        (xhr) => {
                            const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                            this.descriptionEl.textContent = `Loading materials... ${percent}%`;
                        },
                        (error) => {
                            console.error('Error loading MTL:', error);
                            reject(error);
                        }
                    );
                });
            }
            
            expand() {
                const fullscreenContainer = document.getElementById('fullscreen-container');
                const fullscreenModal = document.getElementById('fullscreen-modal');
                const fsTitle = document.getElementById('fullscreen-title');
                const fsDesc = document.getElementById('fullscreen-description');
                fsTitle.textContent = this.titleEl.textContent;
                fsDesc.textContent = this.descriptionEl.textContent;
                
                // Hide expand button when expanded
                this.expandBtn.style.display = 'none';
                
                fullscreenContainer.appendChild(this.viewerContainer);
                fullscreenModal.classList.remove('hidden');
                galleryGrid.classList.add('hidden');
                window.currentlyExpandedViewer = this;
                this.isExpanded = true;
                this.setAnnotationSpheresVisible(true);
                setTimeout(() => this.onWindowResize(), 50);
            }

            collapse() {
                const fullscreenModal = document.getElementById('fullscreen-modal');
                this.container.insertBefore(this.viewerContainer, this.container.firstChild);
                fullscreenModal.classList.add('hidden');
                galleryGrid.classList.remove('hidden');
                this.setAnnotationSpheresVisible(false);
                this.hideAnnotationCallout();
                
                // Show expand button when collapsed
                this.expandBtn.style.display = '';
                this.isExpanded = false;
                
                // Hide context menu if visible
                const contextMenu = document.getElementById('context-menu');
                contextMenu.classList.add('hidden');
                
                // Reset camera and controls to initial state
                if (this.currentObject) {
                    const box = new THREE.Box3().setFromObject(this.currentObject);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    this.modelSize = Math.max(size.x, size.y, size.z);
                    const fov = this.camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(this.modelSize / 2 / Math.tan(fov / 2)) * 1.8;
                    this.camera.position.copy(center);
                    this.camera.position.z += cameraZ;
                    this.camera.rotation.set(0, 0, 0);
                    this.controls.target.copy(center);
                    this.controls.update();
                }
                
                setTimeout(() => this.onWindowResize(), 50);
            }

            frameObject(object) {
                // (Framing logic remains the same)
                const box = new THREE.Box3().setFromObject(object);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                this.modelSize = Math.max(size.x, size.y, size.z);
                const fov = this.camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(this.modelSize / 2 / Math.tan(fov / 2)) * 1.8;
                this.camera.position.copy(center);
                this.camera.position.z += cameraZ;
                this.controls.target.copy(center);
                this.controls.update();
            }

            onWindowResize() {
                const { clientWidth, clientHeight } = this.viewerContainer;
                if (clientWidth === 0 || clientHeight === 0) return;
                this.camera.aspect = clientWidth / clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(clientWidth, clientHeight);
            }

            animate = () => {
                requestAnimationFrame(this.animate);
                this.controls.update();
                if (this.renderer.domElement.isConnected) {
                    this.renderer.render(this.scene, this.camera);
                }
            }

            // --- ANNOTATION METHODS ---
            // (All annotation methods remain the same)
            createRandomAnnotations(object, count) {
                 const vertices = [];
                object.traverse(child => {
                    if (child.isMesh) {
                        const geometry = child.geometry;
                        if (geometry.attributes.position) {
                            const positionAttribute = geometry.attributes.position;
                            for (let i = 0; i < positionAttribute.count; i++) {
                                const vertex = new THREE.Vector3();
                                vertex.fromBufferAttribute(positionAttribute, i);
                                child.localToWorld(vertex);
                                vertices.push(vertex);
                            }
                        }
                    }
                });

                if (vertices.length === 0) return;

                for (let i = 0; i < count; i++) {
                    const randomIndex = Math.floor(Math.random() * vertices.length);
                    const position = vertices[randomIndex];
                    const text = `This is annotation #${i + 1}. It points to a specific feature on the model, providing more details.`;
                    this.addAnnotation({ position, text });
                }
            }
            addAnnotation(data) {
                this.annotations.push(data);
                
                const sphereSize = this.modelSize * 0.02;
                const geometry = new THREE.SphereGeometry(sphereSize, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x3498db,
                    transparent: true,
                    opacity: 0.7
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(data.position);
                sphere.userData.annotationIndex = this.annotations.length - 1;
                sphere.visible = false;

                this.scene.add(sphere);
                this.annotationSpheres.push(sphere);
            }
            clearAnnotations() {
                this.annotationSpheres.forEach(sphere => this.scene.remove(sphere));
                this.annotationSpheres = [];
                this.annotations = [];
                this.hideAnnotationCallout();
            }
            setAnnotationSpheresVisible(isVisible) {
                this.annotationSpheres.forEach(sphere => sphere.visible = isVisible);
            }
            showAnnotationCallout(annotation, sphere) {
                this.isCalloutVisible = true;
                this.annotationCallout.textContent = annotation.text;
                this.annotationCallout.style.visibility = 'visible';
                this.annotationCallout.style.opacity = 1;

                this.connectorSVG.style.visibility = 'visible';
                const calloutRect = this.annotationCallout.getBoundingClientRect();
                const containerRect = this.viewerContainer.getBoundingClientRect();
                
                const toX = calloutRect.left - containerRect.left;
                const toY = calloutRect.top - containerRect.top + (calloutRect.height / 2);

                const screenPosition = sphere.position.clone().project(this.camera);
                const fromX = (screenPosition.x * .5 + .5) * this.renderer.domElement.clientWidth;
                const fromY = (screenPosition.y * -.5 + .5) * this.renderer.domElement.clientHeight;

                this.connectorLine.setAttribute('x1', fromX);
                this.connectorLine.setAttribute('y1', fromY);
                this.connectorLine.setAttribute('x2', toX);
                this.connectorLine.setAttribute('y2', toY);
            }
            hideAnnotationCallout() {
                if (!this.isCalloutVisible) return;
                this.isCalloutVisible = false;
                this.annotationCallout.style.visibility = 'hidden';
                this.annotationCallout.style.opacity = 0;
                this.connectorSVG.style.visibility = 'hidden';
            }
            onCanvasClick = (event) => {
                if (window.currentlyExpandedViewer !== this || this.isDragging) return;

                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.annotationSpheres);

                if (intersects.length > 0) {
                    const clickedSphere = intersects[0].object;
                    const annotationIndex = clickedSphere.userData.annotationIndex;
                    const annotation = this.annotations[annotationIndex];
                    this.showAnnotationCallout(annotation, clickedSphere);
                } else {
                    this.hideAnnotationCallout();
                }
            }

            onContextMenu = (event) => {
                console.log('Context menu event triggered', {
                    event: event,
                    eventTarget: event.target,
                    isExpanded: this.isExpanded,
                    isDragging: this.isDragging,
                    mouseX: event.clientX,
                    mouseY: event.clientY
                });
                
                // Prevent default context menu
                event.preventDefault();
                event.stopPropagation();
                
                // Only handle right-click in expanded view
                if (!this.isExpanded) {
                    console.log('Not showing menu - viewer not expanded');
                    return;
                }

                const menu = document.getElementById('context-menu');
                console.log('Context menu element:', menu);
                
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const modelIntersects = this.raycaster.intersectObject(this.currentObject, true);
                console.log('Model intersections:', modelIntersects);

                if (modelIntersects.length > 0) {
                    this.lastIntersection = modelIntersects[0];
                    menu.style.left = event.pageX + 'px';
                    menu.style.top = event.pageY + 'px';
                    menu.classList.remove('hidden');
                    console.log('Showing menu at:', { x: event.pageX, y: event.pageY });
                } else {
                    menu.classList.add('hidden');
                    console.log('No intersection found - hiding menu');
                }
            }
        }
        
        // --- INITIALIZE GALLERY ---
        window.currentlyExpandedViewer = null;
        const viewers = [];
        
        // Clear any existing content
        galleryGrid.innerHTML = '';
        
        // Create one viewer for each asset directory
        for (let i = 0; i < assetDirectoryNames.length; i++) {
            const dirName = assetDirectoryNames[i];
            const cardContainer = document.createElement('div');
            cardContainer.className = 'rounded-lg shadow-lg overflow-hidden';
            galleryGrid.appendChild(cardContainer);
            const viewer = new AssetViewer(cardContainer, i);
            viewer.loadFromDirectory(dirName);
            viewers.push(viewer);
        }

        document.getElementById('back-to-gallery').addEventListener('click', () => {
            if (window.currentlyExpandedViewer) {
                window.currentlyExpandedViewer.collapse();
                window.currentlyExpandedViewer = null;
            }
        });

    </script>
</body>
</html>

